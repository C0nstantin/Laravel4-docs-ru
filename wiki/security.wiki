== Безопасность ==
{{Meta автор=из официальной документации, переводчик=Proger_XP, id переводчика=2, обновление=30.07.2013}}
{{Meta оригинал=doc4:security}}

{{TOC}}

== Настройка ==
Laravel стремиться сделать реализацию авторизации максимально простой. Фактически, почти всё уже настроено после установки. Настройки хранятся в файле %%(t)app/config/auth.php%%, который содержит несколько хорошо документированных параметров для настройки поведения методов авторизации.

По умолчанию Laravel включает в себя модель %%User%% в папке %%(t)app/models%%, которая может использоваться вместе с драйвером авторизации Eloquent (по умолчанию). При создании ((schema таблицы)) для данной модели убедитесь, что поле пароля принимает как минимум 0 символов.

Если ваше приложение не использует Eloquent, вы можете использовать драйвер %%(t)database%%, который использует ((queries конструктор запросов)) Laravel.

== Хранение паролей ==
Класс %%Hash%% содержит методы для безопасного хэширования с помощью ((ВП:Bcrypt)).

**Хэширование пароля по алгоритму Bcrypt:**
%%
  $password = Hash::make('secret');
%%

**Проверка пароля по хэшу:**
%%
  if (Hash::check('secret', $hashedPassword)) {
    // Пароль подходит...
  }
%%

**Проверка на необходимость перехэширования пароля:**
%%
  if (Hash::needsRehash($hashed)) {
    $hashed = Hash::make('secret');
  }
%%

== Авторизация пользователей ==
Для авторизации пользователя в вашем приложении используется метод %%Auth::attempt()%%:
%%
  if (Auth::attempt(array('email' => $email, 'password' => $password))) {
    return Redirect::intended('dashboard');
  }
%%

Заметьте, что поле **email** не обязательно и оно используется только для примера. Вы должны использовать любое поле, которое соответствует имени пользователя в вашей БД. Метод %%Redirect::intended()%% отправит пользователя на URL, который он пытался просмотреть до того, как запрос был перехвачен ((routing#фильтры_маршрутов фильтром)) авторизации. Дополнительный URL может быть передан в метод, если требуемый адрес не доступен.

Когда вызывается метод %%Auth::attempt()%% возбуждается ((events событие)) %%(t)auth.attempt%%. При успешной авторизации также произойдёт событие %%(t)auth.login%%.

Для определения того, авторизован ли пользователь или нет, можно использовать метод %%Auth::check()%%.

**Проверка авторизации пользователя:**
%%
  if (Auth::check()) {
    // Пользователь уже вошёл в систему...
  }
%%

Если вы хотите предоставить функциональность типа "запомнить меня", то вы можете передать %%true%% вторым параметром к методу %%Auth::attempt()%%, который будет поддерживать авторизацию пользователя без ограничения по времени (пока он вручную не выйдет из системы).

**Авторизация и запоминание пользователя:**
%%
  if (Auth::attempt(array('email' => $email, 'password' => $password), true)) {
    // Пользователь был запомнен...
  }
%%

**Внимание:** если метод %%Auth::attempt()%% вернул %%true%%, то пользователь успешно вошёл в систему.

Вы также можете передать дополнительные условия для запроса к таблице.

**Авторизация пользователя с условиями:**
%%
  if (Auth::attempt(array('email' => $email, 'password' => $password, 'active' => 1))) {
    // Вход, если пользователь активен, не отключен и существует.
  }
%%

Как только пользователь авторизован вы можете обращаться к модели %%User%% и её свойствам.

**Доступ к авторизованному пользователю:**
%%
  $email = Auth::user()->email;
%%

Для простой авторизации пользователя по ID используется метод %%loginUsingId()%%:
%%
  Auth::loginUsingId(1);
%%

Метод %%validate()%% позволяет вам проверить данные для входа без осуществления самого входа.

**Проверка данных для входа без авторизации:**
%%
  if (Auth::validate($credentials)) {
    //
  }
%%

Вы также можете использовать метод %%once()%% для авторизации пользователя в системе только для одного запроса. ((session Сессии)) и ((requests#cookies)) не будут использованы.

**Авторизация пользователя на один запрос:**
%%
  if (Auth::once($credentials)) {
    //
  }
%%

**Выход пользователя из системы:**
%%
  Auth::logout();
%%

== Ручная авторизация ==
Если вам нужно авторизовать существующего пользователя просто передайте его модель в метод %%Auth::login()%%:
%%
  $user = User::find(1);

  Auth::login($user);
%%

Это эквивалентно авторизации пользвоателя через его данные методом %%Auth::attempt()%%.

== Защита маршрутов ==
Вы можете использовать ((routes#Фильтры)) ((routes маршрутов)), чтобы позволить только авторизованным пользователям обращаться к данному маршруту. Изначально Laravel содержит фильтр %%(t)auth%%, который содержится в файле %%(t)app/filters.php%%.

**Защита маршрута:**
%%
  Route::get('profile', array('before' => 'auth', function () {
    // Доступно только авторизованным пользователям...
  }));
%%

== ((#csrf)) Защита от подделки запросов (CSRF) ==
Laravel предоставляет простой способ защиты вашего приложения от подделки межсайтовых запросов ([[ВП:CSRF]]).

**Вставка CSRF-ключа в форму:**
%%(h)
  <input type="hidden" name="_token" value="<?php echo csrf_token(); ?>">
%%

**Проверка переданного CSRF-ключа:**
%%
  Route::post('register', array('before' => 'csrf', function() {
    return 'Вы передали верный ключ!';
  }));
%%

== Простая HTTP-авторизация ==
//HTTP Basic Authentication// - простой и быстрый способ авторизовать пользователей вашего приложения без создания дополнительной страницы входа. Для начала подключите фильтр %%(t)auth.basic%%.

**Защита маршрута фильтром HTTP-авторизации:**
%%
  Route::get('profile', array('before' => 'auth.basic', function () {
    // Доступно только авторизованным пользователям...
  }));
%%

По умолчанию, фильтр %%(t)basic%% будет использовать поле %%$email%% модели объекта при авторизации. Если вы хотите использовать иное поле, можно передать его имя первым параметром методу %%basic()%%:
%%
  return Auth::basic('username');
%%

Вы можете использовать HTTP-авторизацию без установки ((requests#cookie+s)) в ((session сессии)), что особенно удобно для авторизации в API. Для того, чтобы сделать это, зарегистрируйте фильтр, возвращающий результат вызова %%Auth::onceBasic()%%.

**Авторизация без запоминания состояния:**
%%
  Route::filter('basic.once', function () {
    return Auth::onceBasic();
  });
%%

== Сброс и изменение паролей ==

=== Отправка письма о сбросе ==
Большая часть приложений позволяют пользователям сбрасывать свои забытые пароли. Вместо того, чтобы заставлять вам реализовывать эту функциональность в каждом приложении, Laravel предоставляет удобный способ для отправки писем о сбросе пароля и выполнения самого сброса. Для начала убедитесь, что модель %%User%% реализует интерфейс %%Illuminate\Auth\Reminders\RemindableInterface%%. Это уже сделано для модели %%User%%, включённой в фреймворк по умолчанию.

**Реализация интерфейса %%RemindableInterface%%:**
%%
  class User extends Eloquent implements RemindableInterface {

    public function getReminderEmail()
    {
        return $this->email;
    }

  }
%%

Затем вам нужно создать таблицу для хранения ключей сброса паролей. Для создания миграции для таблицы просто выполните команду %%(t)auth:reminders%% интерфейса ((artisan Artisan)).

**Генерация миграции для таблиц сброса паролей:**
%%(sh)
  php artisan auth:reminders

  php artisan migrate
%%

Для отправки уведомления вы можете использовать метод %%Password::remind()%%.

**Отправка уведомления о сбросе пароля:**
%%
  Route::post('password/remind', function () {
    $credentials = array('email' => Input::get('email'));

    return Password::remind($credentials);
  });
%%

Заметьте, что параметры, переданные в метод %%Password::remind()%%, похожи на те, которые передаются методу %%Auth::attempt()%%. Этот метод получит модель %%User%% и отправит соответствующее письмо со ссылкой для сброса. В ((views шаблон)) письма будет передана переменная %%$token%%, которая может быть использвоана для изменения пароля через форму его сброса. Кроме неё будет также передана переменная %%$user%%.

.(alert)
**Внимание:** вы можете указать, какой шаблон должен использоваться при создании сообщения, изменив ((configuration настройку приложения)) %%(t)auth.reminder.email%%. Изначально фреймворк уже содержит нужный шаблон.

Вы можете изменить объект письма, которое отправляется пользователю, передав замыкание в виде второго аргумента методу %%Password::remind()%%:
%%
  return Password::remind($credentials, function ($message, $user) {
    $message->subject('Ваше уведомление о сбросе.');
  });
%%

Как вы можете заметить, в маршруте мы напрямую возвращаем результат вызова метода %%Password::remind()%%. По умолчанию этот метод возвращает переадресацию на текущий адрес, если возникла ошибка при сбросе пароля, при этом устанавливается ((session#одноразов+ые))ая переменная %%(t)error%%, а также %%(t)reason%%, которая используется для извлечения языковой строки из языкового файла %%(t)reminders%%. Если пароль был успешно сброшен, то будет установлена одноразовая переменная %%(t)success%%. Таким образом, ((views шаблон)) для формы сброса пароля должен выглядеть примерно так:
%%(h)
  @if (Session::has('error'))
    {{ trans(Session::get('reason')) }}
  @elseif (Session::has('success'))
    На ваш e-mail было отправлено письмо с инструкциями о сбросе пароля.
  @endif

  <input type="text" name="email">
  <input type="submit" value="Отправить письмо">
%%

=== Сброс пароля ==
Как только пользователь перешёл по ссылке в письме, он будет перенаправлен на форму со скрытым ключом %%(t)token%%, а также полями %%(t)password%% и %%(t)password_confirmation%%. Ниже - пример ((routes маршрута)) для формы сброса:
%%
  Route::get('password/reset/{token}', function ($token) {
    return View::make('auth.reset')->with('token', $token);
  });
%%

А сама форма может выглядеть так:
%%(h)
  @if (Session::has('error'))
    {{ trans(Session::get('reason')) }}
  @endif

  <input type="hidden" name="token" value="{{ $token }}">
  <input type="text" name="email">
  <input type="password" name="password">
  <input type="password" name="password_confirmation">
%%

Обратите внимание, что мы снова используем ((session сессии)) для отображения ошибки, которая могла произойти при сбросе пароля. Дальше мы определяем POST-маршрут, который и произведёт сброс:
%%
  Route::post('password/reset/{token}', function () {
    $credentials = array('email' => Input::get('email'));

    return Password::reset($credentials, function ($user, $password) {
      $user->password = Hash::make($password);

      $user->save();

      return Redirect::to('home');
    });
  });
%%

При успешном сбросе объект %%User%% и пароль будут переданы в замыкание, что позволит вам сохранить изменённую модель. После этого вы можете вернуть объект %%Redirect%% или любой другой тип ответа, что и будет возвращено методом %%Password::reset()%%. Заметьте, что этот метод автоматически проверяет переданный ключ (%%(t)token%%), данные для входа и совпадение введённых паролей.

Также, по аналогии с методом %%Password::remind()%%, если во время сброса произошла ошибка метод %%Password::reset()%% вернёт объект %%Redirect%% на текущий адрес с ((session#одноразов+ые))ыми переменными %%(t)error%% и %%(t)reason%%.

== Шифрование ==
Laravel предоставляет функции для устойчивого шифрование по алгоритму ((ВП:AES-256)) с помощью расширения ((phpdoc:book.mcrypt mcrypt)) для PHP.

**Шифрование строки:**
%%
  $encrypted = Crypt::encrypt('секрет');
%%

.(alert)
**Внимание:** обязательно установите 32-значный ключ **key** в файле %%(t)app/config/app.php%%. Если этого не сделать, зашифрованные строки не будут безопасными.

**Расшифровка строки:**
%%
  $decrypted = Crypt::decrypt($encryptedValue);
%%

**Изменение алгоритма и режима шифрования:**
%%
  Crypt::setMode('ctr');

  Crypt::setCipher($cipher);
%%